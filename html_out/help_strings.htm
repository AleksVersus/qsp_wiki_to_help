<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU">
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Строки [Документация QSP]</title>
<link href="default.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="page group">
<!-- wikipage start -->
<!-- TOC START -->

<!-- TOC END -->
<p>
<a class="wikilink1" href="help_arrays.htm" title="help:arrays">Назад: Массивы</a>
</p>
<h1 class="sectionedit1" id="stroki">Строки</h1>
<div class="level1">
<p>
В <strong>QSP</strong> есть три типа данных: числовой, строковый и кортежи. В данном разделе мы рассмотрим строковый тип данных и способы работы с ним.
</p>
<p>
Если мы присваиваем строковое значение переменной, перед именем такой переменной обязательно нужно ставить символ <code>$</code>. То же самое, если мы <em>извлекаем</em> строковое значение из переменной.
</p>
<p>
</p><pre class="brush: qsp">
$text = "Зелёное яблоко" &amp;! помещаем строковое значение в переменную
*pl $text &amp;! выводим на экран значение строковой переменной
</pre>
<p>
Также рекомендуется к названиям всех функций, возвращающих строковые значения, приписывать символ <code>$</code> для улучшения читаемости кода.
</p>
<p>
</p><pre class="brush: qsp">
$max('Петя','Вася','Лёша','Дима')
$text = $str(453+111)
$name = $input('Введите имя:')
</pre>
</div>
<h2 class="sectionedit2" id="konstanty">Константы</h2>
<div class="level2">
<p>
Под константой следует понимать одно конкретное значение. Например, число <code>1441</code> — это числовая константа, а строка <code>"Зелёные яблоки"</code> — это строковая константа.
</p>
<p>
Если с числовыми константами в <strong>QSP</strong> всё просто (записываем число, используя набор цифр; например, <code>4953</code>), то со строковыми есть несколько нюансов:
</p>
<ul>
<li class="level1"><div class="li"> Строковая константа берётся с двух сторон в кавычки (обрамляется кавычками).</div>
<ul>
<li class="level2"><div class="li"> Кавычки могут быть двух видов: апострофы <code>' '</code> и прямые кавычки <code>" "</code>.</div>
</li>
<li class="level2"><div class="li"> Если нужно в константу включить кавычки того же вида, нужно написать их два раза подряд (<em>экранировать через дублирование</em>): <pre class="brush: qsp">
    *PL 'Byte Soft''s "QSP"'
    *PL "Byte Soft's ""QSP"""
    !Byte Soft's "QSP"
</pre></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> В строковых константах сохраняются переносы строк и отступы:<pre class="brush: qsp">
'Данный текст
будет расположен на
нескольких строках'

$a='И этот
    текст    
также'

a=2 &amp; act 'Многострочное
название': gt 'next'
</pre></div>
</li>
<li class="level1"><div class="li"> Если ошибка допущена внутри строковой константы, то вся многострочная константа будет считаться одной строкой при выводе ошибки.<pre class="brush: qsp">
! ошибка указывается во второй строке
*pl "Хотя на самом
деле ошибка
в четвёртой &lt;&lt;"строке"&gt;&gt;"</pre></div>
</li>
<li class="level1"><div class="li"> Текстовые константы и значения переменных можно объединять двумя способами:</div>
<ul>
<li class="level2"><div class="li"> С помощью оператора конкатенации <code><strong>&amp;</strong></code>. Выражение нужно брать в скобки, т.к. существует ещё разделитель команд <code><strong>&amp;</strong></code>:<pre class="brush: qsp">
! В переменную $res запишется 'x=5 y=6':
$res = ('x=' &amp; x &amp; ' y=' &amp; y)
! В переменную $res запишется  'x=',
! а '5' выведется в основное окно описания:
$res = 'x=' &amp; x
</pre></div>
</li>
<li class="level2"><div class="li"> С помощью оператора сложения <code><strong>+</strong></code>: <pre class="brush: qsp">
! Результат 'x=5 y=6':
$res = 'x=' + x + ' y=' + y
</pre></div>
<ul>
<li class="level3"><div class="li"> Следует соблюдать осторожность, если одно из слагаемых числового типа: <pre class="brush: qsp">
x = 1
$res = '1' + x
!Результат '2' вместо '11'
</pre></div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h3 class="sectionedit3" id="ehkranirovanie">Экранирование</h3>
<div class="level3">
<p>
Чуть выше были приведены два случая экранирования кавычек в строке. Экранирование становится особенно важным, когда мы имеем дело с более сложным вложением кавычек. Например, при работе с <abbr title="HyperText Markup Language">HTML</abbr>-разметкой.
</p>
<p>
Для более полного понимания того, как можно экранировать кавычки в <strong>QSP</strong>, рассмотрим гиперссылку, в которую встроен переход на локацию. Вот как эта ссылка будет выглядеть на экране при отключенном режиме распознавания <abbr title="HyperText Markup Language">HTML</abbr>:
</p>
<p>
</p><pre class="brush: html">
&lt;a href="EXEC: goto 'Верстак' " class="plain"&gt;Верстак&lt;/a&gt;
</pre>
<p>
Если мы заключим нашу ссылку в одинарные кавычки, нам придётся экранировать одинарные кавычки внутри атрибута <strong>href</strong>:
</p>
<p>
</p><pre class="brush: qsp">
*p '&lt;a href="EXEC: goto ''Верстак'' " class="plain"&gt;Верстак&lt;/a&gt;'
</pre>
<p>
Если мы заключим нашу ссылку в двойные кавычки, то нам придётся экранировать непосредственно границы атрибутов от кода <strong>QSP</strong>:
</p>
<p>
</p><pre class="brush: qsp">
*p "&lt;a href=""EXEC: goto 'Верстак' "" class=""plain""&gt;Верстак&lt;/a&gt;"
</pre>
<p>
Есть способ записи, когда нам не приходится экранировать кавычки вообще. Мы просто заключаем ссылку в фигурные скобки (не рекомендуется):
</p>
<p>
</p><pre class="brush: qsp">
*p {&lt;a href="EXEC: goto 'Верстак' " class="plain"&gt;Верстак&lt;/a&gt;}
</pre>
<p>
Может так же пригодиться способ, позволяющий создавать глубокие уровни вложенности кавычек друг в друга и обходиться без экранирования:
</p>
<p>
</p><pre class="brush: qsp">
*p '&lt;a href="EXEC:' + " goto 'Верстак' " + ' " class="plain"&gt;Верстак&lt;/a&gt;'
</pre>
</div>
<h2 class="sectionedit4" id="sravnenie_strok">Сравнение строк</h2>
<div class="level2">
<p>
Точно так же, как и числовые значения, мы можем сравнивать строковые значения. При этом операции сравнения будут возвращать <strong>1</strong>, если равенство верно, и <strong>0</strong>, если равенство неверно.
</p>
<p>
</p><pre class="brush: qsp">
if 'abc'='abc': 'Условие выполнено'
*pl ('abc'='abc') &amp; ! увидим на экране единицу
*pl ('abc'&gt;'ab') &amp; ! увидим на экране единицу
*pl ('abc'&lt;'abc') &amp; ! увидим на экране ноль
</pre>
<p>
Строки сравниваются посимвольно, начиная с крайнего левого символа.
</p>
<p>
</p><pre class="brush: qsp">
! это не валидный код qsp
! а табличка сравнения строковых констант
'ac' = 'ac'
'bc' &gt; 'ac'  &amp;! 'b' &gt; 'a'
'ac' &gt; 'ab'  &amp;! 'c' &gt; 'b'
'b'  &gt; 'ab'  &amp;! 'b' &gt; 'a'
'ab' &gt; 'a'   &amp;! 'b' &gt; ''
</pre>
</div>
<h2 class="sectionedit5" id="podvyrazhenija">Подвыражения</h2>
<div class="level2">
<p>
<strong>QSP</strong> позволяет вставлять значения различных выражений в строковые константы, а так же в базовые описания локаций и названия базовых действий. Для этого используются специальные конструкции из двойных угловых скобок: <code>&lt;&lt;</code> и <code>&gt;&gt;</code>. Выражения, помещённые в такие двойные угловые скобки, называются <strong>подвыражениями</strong>, или <strong>вложенными выражениями</strong>.
</p>
<p>
Примеры:
</p>
<p>
</p><pre class="brush: qsp">
число_гоблинов=5
'Тебя окружили &lt;&lt;число_гоблинов&gt;&gt; гоблинов!'
! на экране будет строка:
! Тебя окружили 5 гоблинов!
</pre>
<p>
</p><pre class="brush: qsp">
pl 'Вас зовут &lt;&lt;$playerName&gt;&gt;, вы находитесь в &lt;&lt;$curloc&gt;&gt;.'
</pre>
<p>
Когда плеер встречает подобное подвыражение, он это подвыражение <em>раскрывает</em>. Это значит, что плеер вычисляет значение выражения в двойных угловых скобках, а затем подставляет полученное значение на место этого самого подвыражения.
</p>
<p>
Другие примеры:
</p>
<p>
</p><pre class="brush: qsp">
pl 'i='+$str(i)
!эквивалентно
pl 'i=&lt;&lt;i&gt;&gt;'
</pre>
<p>
Подвыражения можно вкладывать друг в друга. Здесь очень важно соблюдать чередование кавычек, если вы это делаете:
</p>
<p>
</p><pre class="brush: qsp">
!Вложенные подвыражения:
pl val('&lt;&lt;val("&lt;&lt;i&gt;&gt;")&gt;&gt;&lt;&lt;j&gt;&gt;')
pl val('&lt;&lt;$str(val("&lt;&lt;i&gt;&gt;"))&gt;&gt;')
! Здесь в подвыражения вкладываются другие
! строковые константы с подвыражениями
</pre>
<p>
Если нужно последовательность <code>&lt;&lt;</code> вывести на экран, или поместить в переменную, можно воспользоваться одним из этих способов:
</p>
<ul>
<li class="level1"><div class="li"> Разбить <code>&lt;&lt;</code> на <code>'&lt;'+'&lt;</code>': <pre class="brush: qsp">
$text = '&lt;'+'&lt;var&gt;&gt;'
'string &lt;'+'&lt;var&gt;&gt;'
</pre></div>
</li>
<li class="level1"><div class="li"> Использовать фигурные скобки: <pre class="brush: qsp">
$text={&lt;&lt;var&gt;&gt;}
*pl {string &lt;&lt;var&gt;&gt;}
</pre></div>
</li>
</ul>
<p>
<strong>Фигурные скобки</strong> — это ещё один способ создавать строковые константы. При их использовании создаются точно такие же строковые константы, как и в случае с обычными кавычками, однако в таких константах не раскрываются подвыражения. К тому же текст, размещённый в фигурных скобках не подсвечивается непосредственно как текст различными редакторами (например, Quest Generator), а подсвечивается как обычный код. Поэтому фигурные скобки обычно используют для создания <a class="wikilink1" href="help_dynamical.htm" title="help:dynamical">динамического кода</a>.
</p>
<p>
</p><pre class="brush: qsp">
*pl {
    Это текст в фигурных скобках,
    здесь не раскрываются &lt;&lt;подвыражения&gt;&gt;
}
dynamic {
    ! обычно в фигурных
    ! скобках размещают
    *pl "Код для оператора DYNAMIC"
}
</pre>
</div>
<h2 class="sectionedit6" id="funkcii">Функции</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <code id="func_LEN">LEN([$стр])</code> - возвращает длину строки <code>[$стр]</code>. <pre class="brush: qsp">
*pl len('Зелёные яблоки') &amp;! на экране будет число 14
</pre></div>
</li>
<li class="level1"><div class="li"> <code id="func_MID"><strong>$MID(</strong>[$стр],[#начало],[#длина]<strong>)</strong></code> - вырезает из строки <code>[$стр]</code> строку, которая начинается с символа номер <code>[#начало]</code> и имеет длину <code>[#длина]</code>. Нумерация символов в строке ведётся с <strong>1</strong>.</div>
<ul>
<li class="level2"><div class="li"> Параметр <code>[#длина]</code> может отсутствовать, при этом вырезается вся строка, начиная с символа <code>[#начало]</code>.</div>
</li>
<li class="level2"><div class="li"> Если <code>[#начало]</code> превышает длину строки, функция возвращает пустую строку.</div>
</li>
<li class="level2"><div class="li"> Примеры: <pre class="brush: qsp">
 $MID('abcd', 1, 2) &amp;! 'ab'
 $MID('abcd', 2, 3) &amp;! 'bcd'
 $MID('abcd', 2)    &amp;! 'bcd'
 $mid('abcd',5) &amp;! '' (пустая строка)
</pre></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <code id="func_UCASE">$UCASE([$стр])</code> - возвращает строку больших букв, полученную изменением регистра букв исходной строки <code>[$стр]</code>. <pre class="brush: qsp">
$UCASE('TexT#') &amp;! 'TEXT#'
</pre></div>
</li>
<li class="level1"><div class="li"> <code id="func_LCASE">$LCASE([$стр])</code> - возвращает строку маленьких букв, полученную изменением регистра букв исходной строки <code>[$стр]</code>. <pre class="brush: qsp">
$LCASE('TExT#') &amp;! 'text#'
</pre></div>
</li>
<li class="level1"><div class="li"> <code id="func_TRIM">$TRIM([$стр])</code> - удаляет прилегающие пробелы и символы табуляции из <code>[$стр]</code> и возвращает полученную строку. <pre class="brush: qsp">
$TRIM(' TRIM TEST ') &amp;! 'TRIM TEST'
</pre></div>
</li>
<li class="level1"><div class="li"> <code id="func_REPLACE"><strong>$REPLACE(</strong>[$стр],[$поиск],[$замена],[#количество_замен]<strong>)</strong></code> - заменяет в строке <code>[$стр]</code> несколько вхождений строки <code>[$поиск]</code> строкой <code>[$замена]</code>. Замена производится слева-направо и только для неперескающихся вхождений.</div>
<ul>
<li class="level2"><div class="li"> Параметр <code>[#количество_замен]</code> показывает, сколько вхождений должно быть заменено. Если параметр не указан, производится замена всех вхождений.</div>
</li>
<li class="level2"><div class="li"> Параметр <code>[$замена]</code> может отсутствовать, тогда он принимается равным пустой строке.</div>
</li>
<li class="level2"><div class="li"> Примеры: <pre class="brush: qsp">
$REPLACE('test', '12', '4') &amp;! 'test'
$REPLACE('test', 'e', 's')  &amp;! 'tsst'
$REPLACE('test', 't', '34') &amp;! '34es34'
$REPLACE('test', 't') &amp;! 'es'

$REPLACE('test', 't', 'qu', 1) &amp;! 'quest'
$REPLACE('test my test', 't', 'q', 3) &amp;! 'qesq my qest'
</pre></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <code id="func_INSTR">INSTR([$строка],[$поиск],[#начало])</code> - возвращает номер позиции символа, с которого начинается вхождение строки <code>[$поиск]</code> в строку <code>[$строка]</code> (или <strong>0</strong>, если вхождения нет). Поиск начинается с символа номер <code>[#начало]</code>.</div>
<ul>
<li class="level2"><div class="li"> Параметр <code>[#начало]</code> может отсутствовать, при этом он принимается равным <strong>1</strong>.</div>
</li>
<li class="level2"><div class="li"> Примеры:</div>
</li>
</ul>
</li>
</ul>
<p>
</p><pre class="brush: qsp">
INSTR('ABCDefgh','BC',1) &amp;! 2
INSTR('ABCDefgh','Be',1) &amp;! 0
INSTR('abcdef','abc')    &amp;! 1
</pre>
<ul>
<li class="level1"><div class="li"> <code id="func_ISNUM">ISNUM([$строка])</code> - функция проверяет, является ли строка <code>[$строка]</code> числом. Функция возвращает <code>0</code> (ложь) или <code>1</code> (истина). <pre class="brush: qsp">
ISNUM(' 9999 ') &amp;! 1
ISNUM(' -888')  &amp;! 1
ISNUM('777a6')  &amp;! 0
ISNUM('')
  &amp;! 0, т.к. пустая строка не содержит числа
</pre></div>
</li>
<li class="level1"><div class="li"> <code id="func_VAL">VAL([$стр])</code> - переводит строку цифр <code>[$стр]</code> в соответствующее число. При ошибке возвращает <code>0</code>. <pre class="brush: qsp">
яблоки = VAL($яблоки)
val('123') &amp; ! увидим 123
val('') &amp; ! увидим 0
val('sand') &amp; ! увидим 0
</pre></div>
</li>
<li class="level1"><div class="li"> <code id="func_STR">$STR([#число])</code> - переводит число (числовое выражение) в соответствующую строку. <pre class="brush: qsp">
PL $STR(56)
</pre></div>
</li>
</ul>
</div>
<h2 class="sectionedit7" id="operatory">Операторы</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <code id="statement_SCANSTR">SCANSTR [$имя_массива], [$текст_для_разбора], [$регэксп], [#номер_группы]</code> — оператор ищет в строке <code>[$текст_для_разбора]</code> непересекающиеся фрагменты, соответствующие регулярному выражению <code>[$регэксп]</code>, и помещает их в массив <code>[$имя_массива]</code>. Если параметр <code>[#номер_группы]</code> указан и отличается от нуля, в массив помещается не весь фрагмент целиком, а лишь та его часть, которая соответствует группе с указанным номером.</div>
<ul>
<li class="level2"><div class="li"> Подробное описание оператора и примеры использования в разделе "<a class="wikilink1" href="help_arrays.htm" title="help:arrays">массивы</a>".</div>
</li>
</ul>
</li>
</ul>
<p>
<a class="wikilink1" href="help_regexp.htm" title="help:regexp">Вперёд: Регулярные выражения</a>
</p>
</div>

<!-- wikipage stop -->
</div></body>
</html>