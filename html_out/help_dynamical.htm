<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU">
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Динамический код [Документация QSP]</title>
<link href="default.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="page group">
<!-- wikipage start -->
<!-- TOC START -->

<!-- TOC END -->
<p>
<a class="wikilink1" href="help_service_locations.htm" title="help:service_locations">Назад: Служебные локации</a>
</p>
<h1 class="sectionedit1" id="dinamicheskij_kod">Динамический код</h1>
<div class="level1">
</div>
<h2 class="sectionedit2" id="liricheskoe_vstuplenie_pojasnjajuschee_dlja_chego_mozhet_prigoditsja_dinamicheskij_kod">Лирическое вступление, поясняющее, для чего может пригодиться динамический код</h2>
<div class="level2">
<p>
Из-за своей линейности язык <strong>QSP</strong> лишён некоторых плюшек, которые есть в других языках программирования. Например, если вам нужно вывести на печать массив, вы делаете это с помощью цикла:
</p>
<p>
</p><pre class="brush: qsp">
! массив mass создан заранее
loop local i,size=0,arrsize('mass') while i&lt;size step i+=1:
  *pl mass[i]
end
</pre>
<p>
Но, что если вам нужно вывести на печать десять массивов? Писать на каждый массив по циклу?
</p>
<p>
Гораздо проще написать одну универсальную локацию-функцию (см. раздел <a class="wikilink1" href="help_organizing.htm" title="help:organizing">"Пользовательские функции и процедуры"</a>), передавать в неё название массива и выводить одним и тем же циклом на печать любой массив.
</p>
<p>
И вот для этого нам потребуется использовать динамический код.
</p>
<p>
(на самом деле у этой задачи есть решение и без применения оператора <code>DYNAMIC</code>, но сейчас нас интересует именно динамический код, поэтому продолжим в рамках нужного для примера решения).
</p>
<p>
Динамический код — это код, который мы не знаем заранее. Мы пишем лишь его составные части, а уже при выполнении программы этот код составляется из этих частей в нужные комбинации.
</p>
<p>
Прежде всего стоит спросить себя, из чего состоит любой код? И, кажется, что ответ очевиден: код состоит из команд. Это верно, но чем по сути являются команды? А вот тут ответ очевиден не для всех: команды — это строки текста.
</p>
<p>
Мы с вами прекрасно умеем работать со строками. Если не умеем, то быстренько читаем раздел <a class="wikilink1" href="help_strings.htm" title="help:strings">"Строки"</a> и учимся.
</p>
<p>
Строки можно склеивать, в них можно встраивать подвыражения, из них можно вырезать фрагменты. Вот и с кодом, по сути, можно делать то же самое. Так давайте запишем наш цикл в виде строки:
</p>
<p>
</p><pre class="brush: qsp">
"loop local i,size=0,arrsize('mass') while i&lt;size step i+=1:
  *pl mass[i]
end"
</pre>
<p>
Что мы тут видим? А видим мы, что в этой строке прописано название массива <code>mass</code>, аж целых два раза. Название массива — это значение, которое можно помещать в перемнную, а можно извлекать из переменной.
</p>
<p>
Например, мы поместили название массива в переменную <code>$array_name</code>. Как нам вставить значение этой переменной в наш код, записанный в виде строки? Используем подвыражения:
</p>
<p>
</p><pre class="brush: qsp">
$array_name='mass'
"loop local i,size=0,arrsize('&lt;&lt;$array_name&gt;&gt;') while i&lt;size step i+=1:
  *pl &lt;&lt;$array_name&gt;&gt;[i]
end"
</pre>
<p>
Если мы запустим получившуюся локацию, мы увидим на экране наш цикл с массивом <strong>mass</strong>. Если мы пропишем в переменную <code>$array_name</code> название другого массива, и снова запустим локацию, мы увидим на экране тот же цикл, но с другим массивом. Это значит, что наша строка текста формируется <strong>динамически</strong>!
</p>
<p>
Получается, и код цикла формируется динамически. Нам осталось только научиться запускать на выполнение такой код, записанный в виде строки текста.
</p>
<p>
И вот для этого, как раз, в <strong>QSP</strong> есть специальный оператор: <code>DYNAMIC</code>. Мы просто передаём этому оператору наш записанный в виде текста цикл, и оператор <code>DYNAMIC</code> легко его выполняет, как обычный код QSP:
</p>
<p>
</p><pre class="brush: qsp">
$array_name='mass'
dynamic "loop local i,size=0,arrsize('&lt;&lt;$array_name&gt;&gt;') while i&lt;size step i+=1:
  *pl &lt;&lt;$array_name&gt;&gt;[i]
end"
</pre>
<p>
Таким образом, заменяя значение в переменной <code>$array_name</code>, мы легко выводим на печать любой массив. А чтобы нам было ещё проще, мы создаём специальную локацию-функцию, и ей, в качестве аргументов, будем передавать названия массивов, которые хотим распечатать. Назовём эту локацию <code>print_array</code>:
</p>
<p>
</p><pre class="brush: qsp">
!# print_array
dynamic "loop local i,size=0,arrsize('&lt;&lt;$args[0]&gt;&gt;') while i&lt;size step i+=1:
  *pl &lt;&lt;$args[0]&gt;&gt;[i]
end"
</pre>
<p>
И теперь, как мы выведем на печать любой, какой хотим, массив? Проще простого:
</p>
<p>
</p><pre class="brush: qsp">
@print_array('mass')
@print_array('$unit_name')
@print_array('unit_count')
</pre>
<p>
Вот так возможность работы с динамическим кодом позволяет нам сделать наш код QSP более гибким и легко читаемым.
</p>
</div>
<h2 class="sectionedit3" id="dynamic">DYNAMIC</h2>
<div class="level2">
<p>
<code id="statement_DYNAMIC">DYNAMIC</code> — выполняет код, переданный в виде строки текста. Общая запись:
</p>
<p>
</p><pre class="brush: qsp">
DYNAMIC [$код],[аргумент 0],[аргумент 1], ... ,[аргумент 18]
</pre>
<p>
, где <code>[$код]</code> — это обычный код QSP, записанный в виде текста. Выполнение такого кода аналогично выполнению кода оператора <code>GOSUB</code>. Аргументы <code>[аргумент 0]</code>, <code>[аргумент 1]</code> и т.д. могут использоваться внутри <code>[$код]</code>, их значения автоматически помещаются в ячейки массива <code>args</code>: в <code>ARGS[0]</code>, <code>ARGS[1]</code>, и т.д. соответственно. Внутри выполняемого кода <code>DYNAMIC</code> используется свой собственный массив <code>ARGS</code>, его значения не пересекаются со значениями <code>ARGS</code> на локации, из которой <code>DYNAMIC</code> был вызван. После выполнения кода, переданного оператору <code>DYNAMIC</code>, продолжается выполнение кода со следующей команды после <code>DYNAMIC</code>.
</p>
<p>
Примеры:
</p>
<p>
</p><pre class="brush: qsp">
! простые вызовы кода, записанного в виде текста
dynamic '$a="string&lt;&lt;$b&gt;&gt;"'
dynamic '$a'
dynamic 'if $a="string":''text!'''
! вызов кода с передачей в него аргументов
dynamic "
  *pl $args[0]
  addobj $args[1]
",'Вы взяли вилку.','Вилка'
</pre>
<p>
Нижеследующая информация справедлива и для функции <code>DYNEVAL</code> (см. ниже).
</p>
<p>
<strong>Важно!</strong> Если код задан с помощью одинарных (<code>' '</code>) или двойных (<code>" "</code>) кавычек, подвыражения вычисляются сразу:
</p>
<p>
</p><pre class="brush: qsp">
$args[0]='qwerty'
$code = '
  *pl "&lt;&lt;$args[0]&gt;&gt;"
  *pl $args[0]
'

dynamic $code,'asdfg'
</pre>
<p>
В этом случае при задании переменной <strong>$code</strong> будет вычислено подвыражение, поэтому когда <code>DYNAMIC</code> выполнит код, первой строкой выведется 'qwerty', второй строкой выведется 'asdfg'.
</p>
<p>
Фигурные скобки - третий вид кавычек используемый специально для написания динамического кода. Здесь поддерживается вложенность скобок, а подвыражения не вычисляются:
</p>
<p>
</p><pre class="brush: qsp">
$args[0]='qwerty'
$code = {
  *pl "&lt;&lt;$args[0]&gt;&gt;"
  *pl $args[0]
}

dynamic $code,'asdfg'
</pre>
<p>
В этом случае будут выведены две строки 'asdfg'. Так как подвыражение не вычисляется на момент присвоения кода переменной <strong>$code</strong>, но зато будет вычислено уже при непосредственном выполнении кода оператором <code>DYNAMIC</code>.
</p>
</div>
<h2 class="sectionedit4" id="dyneval">DYNEVAL</h2>
<div class="level2">
<p>
<code id="func_DYNEVAL">DYNEVAL</code> — выполняет код, переданный в виде строки текста, и возвращает результат, если он есть. Общая запись:
</p>
<p>
</p><pre class="brush: qsp">
$DYNEVAL([$код],[аргумент 0],[аргумент 1], ... ,[аргумент 18])
DYNEVAL([$код],[аргумент 0],[аргумент 1], ... ,[аргумент 18])
</pre>
<p>
, где <code>[$код]</code> — это обычный код QSP, записанный в виде текста. Выполнение такого кода аналогично выполнению кода функции <code>FUNC</code>. Аргументы <code>[аргумент 0]</code>, <code>[аргумент 1]</code> и т.д. могут использоваться внутри <code>[$код]</code>, их значения автоматически помещаются в массив <code>ARGS</code>, в ячейки <code>ARGS[0]</code>, <code>ARGS[1]</code>, и т.д. соответственно. Внутри выполняемого кода <code>DYNEVAL</code> используется свой собственный массив <code>ARGS</code>, его значения не пересекаются со значениями <code>ARGS</code> на локации, из которой <code>DYNEVAL</code> была вызвана. После выполнения кода, переданного функции <code>DYNEVAL</code>, продолжается вычисление выражения, в котором расположена функция <code>DYNEVAL</code>.
</p>
<p>
Чтобы <code>DYNEVAL</code> возвращала результат, необходимо внутри <code>[$код]</code> присвоить этот результат переменной <code>RESULT</code>.
</p>
<p>
Примеры:
</p>
<p>
</p><pre class="brush: qsp">
dyneval('result = 3+4')
*pl $dyneval('$result = $mid("abcd",2,1)+"qwerty"')
проход = dyneval("result = ($args[0] &lt;&gt; 'текст')", 'строка')
</pre>
<ul>
<li class="level1"><div class="li"> Чтобы <code>DYNEVAL</code> вернула строковое значение, результат должен быть записан в <code>$RESULT</code>.</div>
</li>
<li class="level1"><div class="li"> Чтобы <code>DYNEVAL</code> вернула числовое значение, результат должен быть записан в <code>RESULT</code>.</div>
</li>
<li class="level1"><div class="li"> Чтобы <code>DYNEVAL</code> вернула несколько значений, результат нужно записать в <code>%RESULT</code> как кортеж значений.</div>
</li>
<li class="level1"><div class="li"> <code>%RESULT</code>, <code>$RESULT</code> и <code>RESULT</code> — это одна и та же переменная, но с разными типами данных. <strong>Следует помнить</strong>, что новая запись значения затирает предыдущее, какого бы типа данных не было это значение.</div>
</li>
</ul>
<p>
Если при выполнении <code>DYNEVAL</code> она не возвращает значения (<code>RESULT</code> не инициализируется), и является единственным элементом выражения, передаваемого неявному оператору, плеер ничего не выведет на экран. Т.е. <code>DYNEVAL</code> будет работать, как <code>DYNAMIC</code>. Пример:
</p>
<p>
</p><pre class="brush: qsp">
! неявный оператор выведет на экран 123:
123
! код в dyneval выполнится, но на экране
! мы ничего не увидим:
dyneval("code = 123 + 890")
! неявный оператор выведет на экран 1013:
code
</pre>
</div>
<h2 class="sectionedit5" id="oblasti_primenenija_dynamic_i_dyneval">Области применения DYNAMIC и DYNEVAL</h2>
<div class="level2">
<p>
<code>DYNAMIC</code> и <code>DYNEVAL</code> следует использовать в нескольких случаях:
</p>
<ul>
<li class="level1"><div class="li"> Когда нет иного способа получить необходимый функционал. Как пример, очень распространённый случай генерации действий с помощью цикла: <pre class="brush: qsp">
loop i=1 while i&lt;=10 step i+=1:
  act "Действие &lt;&lt;i&gt;&gt;": *pl "Действие &lt;&lt;i&gt;&gt;"
end
</pre> В данном случае будут созданы действия с названиями "Действие 1" … "Действие 10". Неопытный автор ожидает, что каждое из этих действий при щелчке по нему будет выводить собственный номер. Однако, это ожидание не верно. Переменная <code>i</code> в данном случае получит значение <strong>10</strong>, и в момент выполнения действия именно это значение подставится в строку, выводимую на экран. То есть подвыражение, относящееся к коду действия, не будет раскрыто плеером, пока игрок не кликнет по действию.<br/>
</div>
</li>
</ul>
<p>
Чтобы действительно сгенерировать действия, которые будут выводить свой правильный номер, раскрытие подвыражения должно происходить в момент создания действия. Как раз для этого и подойдёт оператор <code>DYNAMIC</code>: </p><pre class="brush: qsp">
loop i=1 while i&lt;=10 step i+=1:
  dynamic 'act "Действие &lt;&lt;i&gt;&gt;": *pl "Действие &lt;&lt;i&gt;&gt;"'
end
</pre> В этом случае сначала раскроются подвыражения, а затем готовый код будет передан оператору <code>DYNAMIC</code>. Таким образом сформируются дейстия с уже готовым уникальным кодом действия.

<ul>
<li class="level1"><div class="li"> Также <code>DYNAMIC</code> и <code>DYNEVAL</code> очень удобны, когда нужно выполнить некоторый многострочный код в том месте, где невозможно разместить такой многострочный код. Например, в гиперссылках: <pre class="brush: qsp">
$CODE = {
  if no деньги&lt;100:
    addobj 'Кружка имбирного эля'
    кружка_эля+=1
    деньги-=100
    *pl "Я приобрёл куржку имбирного эля."
  else
    *pl "Мне не хватает денег на эль."
  end
}
*pl "&lt;a href='exec:dynamic $CODE'&gt;Купить кружку имбирного эля&lt;/a&gt;"
</pre> В этом случае переменная <code>$CODE</code> обязательно должна быть глобальной, иначе ссылка её не "увидит". Однако, если необходимо использовать такой код в условиях или циклах, вполне можно обойтись и локальной переменной, чтобы код не висел в памяти: <pre class="brush: qsp">
! этот код не имеет практической пользы. Просто для примера.
local $code = {
  if args[0]+args[1]+args[2]+args[3]=0:
    result=1
  elseif args[0]+args[1]+args[2]+args[3]=4:
    result=1
  else:
    result=0
  end
}
loop while dyneval($code,a,b,c,d):
  a = rand(0,1)
  b = rand(0,1)
  c = rand(0,1)
  d = rand(0,1)
end
</pre> В своём роде это способ создавать анонимные функции в QSP.</div>
</li>
<li class="level1"><div class="li"> Ещё <code>DYNAMIC</code> очень удобен для разного рода <a class="wikilink1" href="help_debugger.htm" title="help:debugger">отладчиков</a>, поскольку позволяет выполнять код QSP, введённый в строку ввода безо всяких танцев с бубном.</div>
</li>
<li class="level1"><div class="li"> <code>DYNAMIC</code> позволяет восстанавливать действия, полученные с помощью функции <code>$CURACTS</code>, и предметы, полученные с помощью функции <code>$CUROBJS</code>: <pre class="brush: qsp">
$acts = $curacts
cla
dynamic $acts
</pre></div>
</li>
</ul>
<p>
Нет смысла использовать динамический код, если вы можете получить тот же результат без его использования. Прежде чем всюду пихать <code>DYNAMIC</code> хорошенько подумайте, а не целесообразнее было бы написать этот код на отдельной локации так, чтобы не приходилось использовать <code>DYNAMIC</code>. Динамический код сложнее читать и на него сложнее ссылаться. Он в принципе ухудшает читаемость кода.
</p>
<p>
Вполне возможно вложение динамического кода в динамический код, то есть <code>DYNAMIC</code>/<code>DYNEVAL</code> внутри <code>DYNAMIC</code>/<code>DYNEVAL</code>, однако это мало того, что ухудшает читаемость, так ещё и очень часто приводит к багам, которые трудно отловить. Банально, неверная закрытая кавычка внутри кода внутри кода может вызвать ошибку, выбиваемую вообще не понятно в какой строке локации. Тем не менее число вложений не ограничено.
</p>
<p>
<a class="wikilink1" href="help_menu.htm" title="help:menu">Вперёд: Всплывающее меню</a>
</p>
</div>

<!-- wikipage stop -->
</div></body>
</html>