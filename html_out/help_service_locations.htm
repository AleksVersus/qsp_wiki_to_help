<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU">
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Служебные локации [Документация QSP]</title>
<link href="default.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="page group">
<!-- wikipage start -->
<!-- TOC START -->

<!-- TOC END -->
<p>
<a class="wikilink1" href="help_jump.htm" title="help:jump">Назад: Переходы внутри локации</a>
</p>
<h1 class="sectionedit1" id="sluzhebnye_lokacii">Служебные локации</h1>
<div class="level1">
<p>
В <strong>QSP</strong> существует возможность привязать вызов некоторых локаций к определённым событиям. Например, к выделению предмета в окне предметов, или к переходу на новую локацию с помощью операторов <code>GOTO</code>/<code>XGOTO</code>.
</p>
<p>
Чтобы привязать вызов локации к определённому событию, нужно прописать название этой локации в ту или иную системную переменную, предназначенную для связки события с локацией.
</p>
<p>
</p><pre class="brush: qsp">
! назначили обработчик выделения предмета:
$onobjsel = 'ONOBJSEL'
! назначили обработчик перехода на новую локацию:
$onnewloc = 'перерисовка'
! сняли обработчик добавления предмета:
$onobjadd = ''
</pre>
<p>
<strong>Примечание:</strong> При использовании операторов "<code>KILLALL</code>, <code>KILLVAR</code>" очищаются также все системные переменные. В том числе и переменные, через которые назначаются локации-обработчики.
</p>
<p>
Когда событие происходит, указанная локация вызывается точно так же, как если бы мы вызывали её с помощью оператора <code><strong><a class="wikilink1" href="help_organizing.htm" title="help:organizing">GOSUB</a></strong></code>, с тем исключением, что на всех служебных локациях восстанавливаются глобальные переменные. Пример:
</p>
<p>
</p><pre class="brush: qsp">
# start
$ongsave = 'ogs'
i = 99

act 'Save Game':
    local i = 17
    ! на экран будет выведено значение 99
    savegame '1.sav'
end

act 'Print i':
    local i = 137
    ! на экран будет выведено 137
    gosub 'ogs'
end
--

# ogs
*pl i
--
</pre>
<p>
В этом примере при сохранении игры на экран будет выведено число 99 из глобальной переменной <code>i</code>. Если же локация <code>ogs</code> вызывается не как служебная, на неё транслируются значения локальной переменной <code>i</code>, объявленной в действии.
</p>
</div>
<h2 class="sectionedit2" id="sobytija_v_qsp">События в QSP</h2>
<div class="level2">
<p>
В этом разделе перечислены все события в <strong>QSP</strong>, к которым можно привязать автоматический вызов локаций.
</p>
</div>
<h3 class="sectionedit3" id="zagruzka_sostojanija_igry">Загрузка состояния игры</h3>
<div class="level3">
<p>
<code id="variable_ONGLOAD">$ONGLOAD</code> — содержит название локации-обработчика события "загрузка состояния игры" (далее "обработчик загрузки состояния"). Иными словами, в эту переменную записывается название локации, код которой будет выполняться всякий раз после того, как был загружен файл состояния игры ("файл сохранения") с помощью команды <code>OPENGAME</code>. Название локации может быть любым.
</p>
<p>
Назначаем в качестве обработчика загрузки состояния локацию "<code>on_game_load</code>":
</p>
<p>
</p><pre class="brush: qsp">
$ongload="on_game_load"
</pre>
<p>
Теперь сразу после выполнения команды <code>OPENGAME</code> плеер будет автоматически вызывать локацию "<code>on_game_load</code>".
</p>
<p>
Чтобы отключить обработчик загрузки состояния, нужно задать переменной <code>$ONGLOAD</code> пустое значение:
</p>
<p>
</p><pre class="brush: qsp">
$ongload=""
</pre>
</div>
<h3 class="sectionedit4" id="soxranenie_sostojanija_igry">Сохранение состояния игры</h3>
<div class="level3">
<p>
<code id="variable_ONGSAVE">$ONGSAVE</code> - содержит название локации-обработчика события "сохранение состояния игры" (далее "обработчик сохранения состояния"). Иными словами, в эту переменную записывается название локации, код которой будет выполняться всякий раз перед тем, как записать состояние игры в новый, или уже существующий, файл состояния игры ("файл сохранения") с помощью команды <code>SAVEGAME</code>. Название локации может быть любым.
</p>
<p>
Назначаем в качестве обработчика сохранения состояния локацию "<code>on_game_save</code>":
</p>
<p>
</p><pre class="brush: qsp">
$ongsave="on_game_save"
</pre>
<p>
Теперь сразу после выполнения команды <code>SAVEGAME</code> плеер будет автоматически вызывать локацию "<code>on_game_save</code>".
</p>
<p>
Чтобы отключить обработчик сохранения состояния, нужно задать переменной <code>$ONGSAVE</code> пустое значение:
</p>
<p>
</p><pre class="brush: qsp">
$ongsave=""
</pre>
</div>
<h3 class="sectionedit5" id="dobavlenie_predmeta_v_okno_predmetov">Добавление предмета в окно предметов</h3>
<div class="level3">
<p>
<code id="variable_ONOBJADD">$ONOBJADD</code> — содержит название локации-обработчика события "добавление предмета в окно предметов" (далее "обработчик добавления предмета"). Иными словами, в эту переменную записывается название локации, код которой выполняется всякий раз после добавления предмета в окно предметов с помощью команды <code>ADDOBJ</code>. Название локации может быть любым.
</p>
<p>
При добавлении предмета этой локации-обработчику передаются два аргумента, значения которых можно получить из <code>$ARGS[0]</code> и <code>$ARGS[1]</code> соответственно:
</p>
<ul>
<li class="level1"><div class="li"> <code>$ARGS[0]</code> - название добавленного предмета</div>
</li>
<li class="level1"><div class="li"> <code>$ARGS[1]</code> - путь к картинке добавленного предмета</div>
</li>
</ul>
<p>
Данная локация полезна, к примеру, для ограничения вместительности рюкзака.
</p>
<p>
Назначаем в качестве обработчика добавления предмета локацию "<code>on_object_add</code>":
</p>
<p>
</p><pre class="brush: qsp">
$onobjadd="on_object_add"
</pre>
<p>
Теперь сразу после выполнения команды <code>ADDOBJ</code> плеер будет автоматически вызывать локацию "<code>on_object_add</code>".
</p>
<p>
Чтобы отключить обработчик добавления предмета, нужно задать переменной <code>$ONOBJADD</code> пустое значение:
</p>
<p>
</p><pre class="brush: qsp">
$onobjadd=""
</pre>
</div>
<h3 class="sectionedit6" id="udalenie_predmeta_iz_okna_predmetov">Удаление предмета из окна предметов</h3>
<div class="level3">
<p>
<code id="variable_ONOBJDEL">$ONOBJDEL</code> — содержит название локации-обработчика события "удаление предмета" (далее "обработчик удаления предмета"). Иными словами, в эту переменную записывается название локации, код которой выполняется всякий раз после удаления предмета с помощью команды <code>DELOBJ</code>. Если воспользоваться командой <code>KILLOBJ</code>, то это будет аналогично серии команд <code>DELOBJ</code>, соответственно и локация-обработчик будет вызвана столько раз, сколько предметов будет удалено с помощью <code>KILLOBJ</code>. Название локации может быть любым.
</p>
<p>
При использовании команды <code>KILLALL</code> локация-обработчик удаления предмета не вызывается, поскольку системная переменная <code>$ONOBJDEL</code> уничтожается раньше удаления предметов.
</p>
<p>
При удалении предмета обработчику удаления предмета передаётся аргумент, значение которого можно получить из <code>$ARGS[0]</code>:
</p>
<ul>
<li class="level1"><div class="li"> <code>$ARGS[0]</code> - название удалённого предмета</div>
</li>
</ul>
<p>
Назначаем в качестве обработчика удаления предмета локацию "<code>on_object_del</code>":
</p>
<p>
</p><pre class="brush: qsp">
$onobjdel="on_object_del"
</pre>
<p>
Теперь сразу после выполнения команды <code>DELOBJ</code> плеер будет автоматически вызывать локацию "<code>on_object_del</code>". А сразу после выполнения команды <code>KILLOBJ</code> локация "<code>on_object_del</code>" будет вызвана столько раз, сколько предметов удалено этой командой.
</p>
<p>
Данная локация полезна, к примеру, для проверки возможности удаления предмета:
</p>
<p>
</p><pre class="brush: qsp">
! например есть предмет, который нам пригодится по сюжету
if $args[0]="Важный артефакт":
    ! восстанавливаем предмет
    addobj $args[0]
end
</pre>
<p>
Чтобы отключить обработчик удаления предмета, нужно задать переменной <code>$ONOBJDEL</code> пустое значение:
</p>
<p>
</p><pre class="brush: qsp">
$onobjdel=""
</pre>
</div>
<h3 class="sectionedit7" id="vydelenie_predmeta_v_okne_predmetov">Выделение предмета в окне предметов</h3>
<div class="level3">
<p>
<code id="variable_ONOBJSEL">$ONOBJSEL</code> — содержит название локации-обработчика события "выделение предмета" (далее "обработчик выделения предмета"). Иными словами, в этой переменной указывается название локации, код на которой выполняется всякий раз при выделении предмета. Выделение предмета происходит непосредственно при "нажатии" на предмет (щелчок мышью по предмету). Название локации может быть любым.
</p>
<p>
Назначаем в качестве обработчика выделения предмета локацию "<code>on_object_select</code>":
</p>
<p>
</p><pre class="brush: qsp">
$onobjsel="on_object_select"
</pre>
<p>
Теперь всякий раз после щелчка мышью на предмете будет выполняться код локации "<code>on_object_select</code>".
</p>
<p>
Данная локация полезна, к примеру, для вывода информации о предмете, или для вызова меню предмета. Получить название выбранного предмета можно через функцию <code>$SELOBJ</code>.
</p>
<p>
</p><pre class="brush: qsp">
if $selobj = 'чайник':
    p 'Cамый обычный чугунный чайник.'
end
</pre>
<p>
При выборе играющим какого-либо предмета, он остаётся выделенным. Повторно выделить уже выделенный предмет нельзя. Снять выделение можно командой <code>UNSELECT</code>.
</p>
<p>
</p><pre class="brush: qsp">
if $selobj = 'нож':
    *p 'Этим ножом даже хлеба не нарежешь.'
end
unselect &amp;! или UNSEL
</pre>
</div>
<h3 class="sectionedit8" id="perexod_na_novuju_lokaciju">Переход на новую локацию</h3>
<div class="level3">
<p>
<code id="variable_ONNEWLOC">$ONNEWLOC</code> — содержит название локации-обработчика перехода на новую локацию (далее "обработчик перехода"). Иными словами, в эту переменную записывается название локации, код которой выполняется каждый раз после выполнения кода локации, на которую был осуществлён переход с помощью операторов <code>GOTO</code> или <code>XGOTO</code>. Управление игрой передаётся игроку уже после выполнения кода на этой локации-обработчике. Название локации может быть любым.
</p>
<p>
Назначаем в качестве обработчика перехода локацию "<code>on_goto_newloc</code>":
</p>
<p>
</p><pre class="brush: qsp">
$onnewloc="on_goto_newloc"
</pre>
<p>
Теперь всякий раз после выполнения кода локации, на которую был осуществлён переход с помощью операторов <code>GOTO</code> или <code>XGOTO</code>, будет автоматически вызываться локация "<code>on_goto_newloc</code>".
</p>
<p>
Получить название локации, на которую был осуществлён переход, можно с помощью функции <code>$CURLOC</code>.
</p>
<p>
</p><pre class="brush: qsp">
if $curloc = 'дом': кошка = 1
</pre>
<p>
Чтобы отключить обработчик перехода, нужно задать переменной <code>$ONNEWLOC</code> пустое значение:
</p>
<p>
</p><pre class="brush: qsp">
$onnewloc=""
</pre>
</div>
<h3 class="sectionedit9" id="vydelenie_dejstvija">Выделение действия</h3>
<div class="level3">
<p>
<code id="variable_ONACTSEL">$ONACTSEL</code> — содержит название локации-обработчика события "выделение действия" (обработчик выделения действий). Иными словами, в этой переменной указывается название локации, код на которой срабатывает, когда одно из выведенных на экран действий выделяется. Название локации может быть любым.
</p>
<p>
Следует помнить, что выделение действия происходит при наведении на него указателя мыши, а не при непосредственном нажатии.
</p>
<p>
Действие нельзя выделить повторно, если оно уже выделено.
</p>
<p>
Важно! При управлении действиями с цифровой клавиатуры, выделение действий может "прыгать", из-за чего работа обработчика выделения действий может быть некорректна.
</p>
<p>
Назначаем в качестве обработчика выделения действий локацию "<code>on_mouse</code>":
</p>
<p>
</p><pre class="brush: qsp">
$onactsel="on_mouse"
</pre>
<p>
Теперь всякий раз при наведении указателя мыши на любое из действий в окне действий, будет вызываться локация "<code>on_mouse</code>".
</p>
<p>
Данная локация полезна, к примеру, для вывода изображений или проигрывания звуков при выборе действий. Получить название выбранного действия можно через функцию <code>$SELACT</code>.
</p>
<p>
</p><pre class="brush: qsp">
if instr(1,$selact,'пойти'): play 'sounds\walk.mp3'
</pre>
<p>
Чтобы отключить обработчик выделения действий, нужно задать переменной <code>$ONACTSEL</code> пустое значение:
</p>
<p>
</p><pre class="brush: qsp">
$onactsel=""
</pre>
</div>
<h3 class="sectionedit10" id="vvod_v_stroke_vvoda">Ввод в строке ввода</h3>
<div class="level3">
<p>
<code id="variable_USERCOM">$USERCOM</code> — содержит название локации-обработчика строки ввода (поля ввода) (далее "обработчик ввода"). Код данной локации-обработчика выполняется, если курсор установлен в строку ввода в момент нажатия клавиши "Enter". Название локации может быть любым.
</p>
<p>
Назначаем в качестве локации-обработчика строки ввода локацию "<code>user_command_line</code>":
</p>
<p>
</p><pre class="brush: qsp">
$usercom="user_command_line"
</pre>
<p>
Теперь, если игрок установит курсор в строку ввода и начнёт нажимать клавишу "Enter", всякий раз при нажатии клавиши "Enter" будет вызываться локация "<code>user_comand_line</code>".
</p>
<p>
Полезна при организации парсера (управление игрой с помощью строки ввода), или для организации отладчика. Получить текст, введённый игроком в поле ввода, можно с помощью функции <code>$USER_TEXT</code>.
</p>
<p>
Пример кода для локации-обработчика:
</p>
<p>
</p><pre class="brush: qsp">
! если введённый текст соответствует названию существующей локации
if (loc $user_text)=-1:
    ! осуществляем переход на эту локацию
    goto $user_text
elseif instr($user_text,'&gt;')=1:
    ! если первый символ в строке ввода это "&gt;" ,
    ! выполняем введённый в строку текст, как код
    dynamic $mid($user_text,2)
end
</pre>
<p>
Чтобы отключить обработчик ввода, нужно задать переменной <code>$USERCOM</code> пустое значение:
</p>
<p>
</p><pre class="brush: qsp">
$usercom=""
</pre>
<p>
Так же см. статью <a class="wikilink1" href="help_inputs.htm" title="help:inputs">"Ввод текста игроком"</a>.
</p>
</div>
<h2 class="sectionedit11" id="lokacija-schjotchik">Локация-счётчик</h2>
<div class="level2">
<p>
Локация-счётчик не является обработчиком какого-то события, как такового. Она вызывается через примерно равные промежутки времени, поэтому здесь мы выделяем её в отдельную группу. Тем не менее, всё, что справедливо для локаций-обработчиков событий, справедливо и для локации-счётчика.
</p>
<p>
<code id="variable_COUNTER">$COUNTER</code> — содержит название локации-счётчика. Локация-счётчик может использоваться для реалтаймовых событий (то есть событий, происходящих в действительном времени); например, плавное изменение цвета фона, постепенный вывод текста на экран, плейлист для постоянного проигрывания музыки и другие. Название локации может быть любым.
</p>
<p>
Как правило, чтобы не путаться, локацию называют так же, как и служебную переменную — "Counter":
</p>
<p>
</p><pre class="brush: qsp">
$counter='Counter'
</pre>
<p>
Чтобы отключить выполнение локации-счётчика, нужно задать пустое значение переменной <code>$COUNTER</code>:
</p>
<p>
</p><pre class="brush: qsp">
$counter=""
</pre>
</div>
<h3 class="sectionedit12" id="settimer">SETTIMER</h3>
<div class="level3">
<p>
Локация-счетчик вызывается через одинаковые промежутки времени, по умолчанию каждые 500 мс, т.е. 2 раза в секунду. Автоматическое обновление интерфейса срабатывает с той же частотой. Промежутки задаются оператором <code>SETTIMER</code> в миллисекундах.
</p>
<p>
<strong>Внимание!!!</strong> Период, выставляемый через <code>SETTIMER</code> — это очень условная величина. Он показывает только примерное время, когда локация-счётчик будет добавлена на выполнение в очередь. Непосредственно выполниться локация-счётчик может чуть позже, а то и сильно позже. Будьте бдительны.
</p>
<p>
Если ваша локация-счётчик называется "<code>on_time</code>", на самой первой локации в игре нужно написать:
</p>
<p>
</p><pre class="brush: qsp">
$counter='on_time'
</pre>
<p>
Теперь, если вы не использовали оператор <code>SETTIMER</code>, примерно каждые 500 миллисекунд будет вызываться локация "<code>on_time</code>".
</p>
<p>
Примеры выставления таймера:
</p>
<p>
</p><pre class="brush: qsp">
SETTIMER 1000/частота_в_герцах
</pre>
<p>
</p><pre class="brush: qsp">
SETTIMER 1000*период_в_секундах
</pre>
<p>
Так же см. статью <a class="wikilink1" href="help_realtime.htm" title="help:realtime">"Реальное время"</a>.
</p>
</div>
<h2 class="sectionedit13" id="neskolko_obrabotchikov_na_odno_sobytie">Несколько обработчиков на одно событие</h2>
<div class="level2">
<p>
Иногда возникает необходимость разгрузить локации-обработчики от большого объёма кода, или разнести логически не связанные фрагменты кода по разным локациям, но привязать код этих локаций к одному событию.
</p>
<p>
Эта задача решается двумя способами.
</p>
<ul>
<li class="level1"><div class="li"> Назначаем в качестве локации-обработчика какого-либо события одну локацию, а уже из неё с помощью <code>GOSUB</code> вызываем необходимые локации, на которых мы разместили фрагменты кода: <pre class="brush: qsp">
     ! самая первая локация в игре     $counter='counter'
</pre><pre class="brush: qsp">
! локация counter
gosub 'playlist'
gosub 'rabbit_hole','animation'
</pre></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Используем системную переменную, в которую обычно прописываем название локации-обработчика, как массив, и прописываем локации, на которых мы разместили фрагменты кода, в ячейки этого массива: <pre class="brush: qsp">
     $counter[0]='playlist'     $counter[1]='rabbit_hole'
</pre> В данном случае плеер будет последовательно одну за другой вызывать локации, прописанные в этом массиве, пока массив не кончится, или пока плеер не встретит пустую ячейку (пустую строку в ячейке).</div>
</li>
</ul>
<p>
Обратите внимание на преимущества и недостатки каждого способа.
</p>
<p>
Первый способ позволяет вызывать сторонние локации из локации-обработчика, передавая на эти локации различные аргументы. Иногда это бывает очень удобно. Однако этот способ не даёт гибкости в управлении фрагментами кода. Вы не можете отключить вызов одной из сторонних локаций.
</p>
<p>
Второй способ, напротив, делает все перечисленные в массиве локации локациями-обработчиками, и чтобы отключить обработку одной из этих локаций, достаточно удалить соответствующую ячейку. Однако, он не позволяет передавать на локации-обработчики необходимые аргументы.
</p>
<p>
<a class="wikilink1" href="help_dynamical.htm" title="help:dynamical">Вперёд: Динамический код</a>
</p>
</div>

<!-- wikipage stop -->
</div></body>
</html>