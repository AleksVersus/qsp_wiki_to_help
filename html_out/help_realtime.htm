<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU">
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Реальное время [Документация QSP]</title>
<link href="default.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="page group">
<!-- wikipage start -->
<!-- TOC START -->

<!-- TOC END -->
<p>
<a class="wikilink1" href="help_savegame.htm" title="help:savegame">Назад: Файлы сохранений</a>
</p>
<h1 class="sectionedit1" id="realnoe_vremja">Реальное время</h1>
<div class="level1">
<p>
Прежде всего следует понимать, что весь код в <strong>QSP</strong> выполняется линейно, последовательно, команда за командой. Так же имейте ввиду, что локации (и другие блоки кода) ставятся на выполнение в очередь, и никогда код в них не выполняется одновременно. Понимание двух этих простых вещей поможет вам лучше проектировать код в локации-счётчике и управлять событиями в реальном времени.
</p>
<p>
В <strong>QSP</strong> нельзя работать с текущим календарным временем. То есть <strong>QSP</strong> не может получать настоящие значения времени с компьютера.
</p>
</div>
<h2 class="sectionedit2" id="operator_zaderzhki_wait">Оператор задержки WAIT</h2>
<div class="level2">
<p>
<code id="statement_WAIT">WAIT</code> — приостановка выполнения кода программы на указанное количество миллисекунд. Общая запись:
</p>
<p>
</p><pre class="brush: qsp">
WAIT [#миллисекунды]
</pre>
<p>
, где <code>[#миллисекунды]</code> — время в миллисекундах, на какое следует остановить выполнение кода программы. 1 секунда равна 1000 миллисекунд.
</p>
<p>
Пример:
</p>
<p>
</p><pre class="brush: qsp">
! остановка выполнения программы на 5 секунд
wait 5000
</pre>
<p>
Использовать данный оператор нужно очень умеренно и осторожно, потому что он полностью блокирует для игрока возможность взаимодействия с игрой. Это может сильно раздражать.
</p>
<p>
А ещё при использовании данного оператора откладывается вызов локации-счётчика, поэтому если вы уже используете локацию-счётчик в своей игре, использовать данный оператор противопоказано.
</p>
<p>
Очень рекомендуем вообще не использовать данный оператор, или использовать только во время тестов, для задержек в различных циклических действиях, или визуализации процессов.
</p>
<p>
В <strong>qSpider</strong> у игрока есть возможность кликом мыши прервать задержку и продолжить игру.
</p>
</div>
<h2 class="sectionedit3" id="funkcija_msecscount">Функция MSECSCOUNT</h2>
<div class="level2">
<p>
<code id="func_MSECSCOUNT">MSECSCOUNT</code> — в любом месте игры возвращает количество миллисекунд, прошедших с момента начала игры. Данная функция при использовании на локации-счётчике позволяет организовывать различные события, происходящие в реальном времени. Также с помощью этой функции можно делать замеры быстродействия различных участков кода в вашей игре:
</p>
<p>
</p><pre class="brush: qsp">
i=0
old_time = msecscount
:for
if i&lt;100000:
    d[i]=i
    i+=1
    jump 'for'
end
new_time = msecscount
pl "Скорость работы старого цикла: "+$str(new_time-old_time)

old_time = msecscount
loop i=0 while i&lt;100000 step i+=1:
    b[i]=i
end
new_time = msecscount
pl "Скорость работы нового цикла: " + $str(new_time-old_time)
</pre>
<p>
Максимальное число, которое может вернуть данная функция, это <strong>2147483647</strong>. Не трудно посчитать, что этого хватит более, чем на <strong>550</strong> часов игры.
</p>
</div>
<h2 class="sectionedit4" id="sobytija_v_realnom_vremeni_tajmer">События в реальном времени. Таймер</h2>
<div class="level2">
<p>
В <strong>QSP</strong> есть возможность выполнять код через определённые промежутки времени — для этого используется локация-счётчик.
</p>
<p>
Чтобы локация-счётчик заработала, необходимо внести её название в служебную переменную <code>$COUNTER</code>. Например, если ваша локация-счётчик называется <strong><code>Счётчик</code></strong>, на самой первой локации в игре нужно написать:
</p>
<p>
</p><pre class="brush: qsp">
$counter='Счётчик'
</pre>
<p>
Как правило, чтобы не путаться, локацию называют так же, как и служебную переменную — <strong><code>Counter</code></strong>:
</p>
<p>
</p><pre class="brush: qsp">
$counter='Counter'
</pre>
<p>
Затем на созданной локации-счётчике пишут код, который должен выполняться через определённые промежутки времени.
</p>
<p>
По умолчанию, код на локации-счётчике выполняется каждые пол секунды (500 миллисекунд). Но это значение можно изменить, использовав оператор <code>SETTIMER</code>:
</p>
<p>
</p><pre class="brush: qsp">
! устанавливает период выполнения кода
! на локации-счётчике в 100 миллисекунд
SETTIMER 100
</pre>
<p>
Комбинируя возможности операторов, функций и локации-счётчика, можно задавать множество событий, выполняемых в реальном времени. Для примера приведён код локации-счётчика, который будет выводить строки текста одну за одной каждые полторы секунды:
</p>
<p>
</p><pre class="brush: qsp">
settimer 20
if стихотворение=0:
  if время_первая_строка=0:
    время_первая_строка=msecscount+1500
  end
  if msecscount&gt;=время_первая_строка:
    *pl 'Веленью совести, о Муза, будь послушна!'
    стихотворение=1
  end
end
if стихотворение=1:
  if время_вторая_строка=0:
    время_вторая_строка=msecscount+1500
  end
  if msecscount&gt;=время_вторая_строка:
    *pl 'Обиды не страшась, не требуя венца,'
    стихотворение=2
  end
end
if стихотворение=2:
  if время_третья_строка=0:
    время_третья_строка=msecscount+1500
  end
  if msecscount&gt;=время_третья_строка:
    *pl 'Хвалу и клевету приемли равнодушно'
    стихотворение=3
  end
end
if стихотворение=3:
  if время_четвёртая_строка=0:
    время_четвёртая_строка=msecscount+1500
  end
  if msecscount&gt;=время_четвёртая_строка:
    *pl 'И не оспаривай глупца.'
    стихотворение=4
  end
end
</pre>
<p>
На самом деле не стоит полагаться на то, что локация-счётчик будет вызываться с заданной периодичностью, поскольку в действительности она не вызывается через определённые промежутки, а просто добавляется в очередь к вызову.
</p>
<p>
Например, вы запустили игру, и на Стартовой локации назначили локацию-счётчик и период обращения в 20 мс, но на выполнение кода на Стартовой локации требуется 40 мс. Прервётся ли в этом случае код на стартовой локации, чтобы плеер выполнил код на локации-счётчике, а затем продолжил выполнять код на Стартовой локации? Нет. Плеер поставит локацию-счётчик в очередь сразу после стартовой локации, если к моменту, когда выполнение кода Стартовой локации завершится, пройдёт 20 мс или более. То есть первый вызов локации-счётчика произойдёт не через 20, а через 40 мс, плюс-минус пара миллисекунд.
</p>
</div>
<h2 class="sectionedit5" id="operator_settimer">Оператор SETTIMER</h2>
<div class="level2">
<p>
<code id="statement_SETTIMER">SETTIMER</code> — задаёт интервал обращения к локации-счётчику. Общая запись:
</p>
<p>
</p><pre class="brush: qsp">
SETTIMER [#выражение]
</pre>
<p>
, где <code>[#выражение]</code> — период обращения к локации-счётчику в миллисекундах. По умолчанию плеер обращается к локации-счётчику каждые 500 мс., т.е. 2 раза в секунду.
</p>
<p>
Установка периода обращения к локации-счётчику влияет и на частоту автоматического обновления настроек интерфейса.
</p>
<p>
Примеры:
</p>
<p>
</p><pre class="brush: qsp">
! локация-счётчик будет запускаться каждые 2 секунды:
settimer 2000
</pre>
<p>
</p><pre class="brush: qsp">
! локация-счётчик будет запускаться 4 раза в секунду:
settimer 250
</pre>
<p>
</p><pre class="brush: qsp">
! если мы задаём частоту обращения (раз в секунду)
frequency=10 &amp; ! десять раз в секунду
settimer 1000/frequency
</pre>
<p>
</p><pre class="brush: qsp">
! если мы задаём период обращения (через сколько секунд)
period=2 &amp; ! каждые две секунды
settimer 1000*period
</pre>
<p>
Минимальное значение периода таким образом может быть 1 миллисекунда:
</p>
<p>
</p><pre class="brush: qsp">
settimer 1
</pre>
<p>
Однако на практике минимальное значение ограничено мощностью вашего компьютера, и оно, как правило, выше 1 миллисекунды. Для проверки фактического времени обращения к локации-счётчику можно использовать на локации-счётчике простой код:
</p>
<p>
</p><pre class="brush: qsp">
! settimer 1
if msecscount  &lt; 10000:
  old = new
  new = msecscount
  pl new - old
end
</pre>
<p>
В течение десяти секунд будут выводиться фактические значения времени, прошедшего между вызовами локации-счётчика.
</p>
<p>
Если установить период обращения к локации-счётчику равный нулю, локация-счётчик не будет вызываться совсем:
</p>
<p>
</p><pre class="brush: qsp">
! отключаем вызовы локации-счётчика
settimer 0
</pre>
<p>
Смотрите так же, как реализуется игровое время, не привязанное к действительному:
</p>
<ul>
<li class="level1"><div class="li"> <a class="urlextern" href="https://qsp.org/index.php?option=com_agora&amp;task=topic&amp;id=956&amp;Itemid=57" rel="nofollow" target="_blank" title="https://qsp.org/index.php?option=com_agora&amp;task=topic&amp;id=956&amp;Itemid=57">Юлианских календарь от evp</a></div>
</li>
<li class="level1"><div class="li"> <a class="urlextern" href="https://qsp.org/index.php?option=com_agora&amp;task=topic&amp;id=956&amp;Itemid=57" rel="nofollow" target="_blank" title="https://qsp.org/index.php?option=com_agora&amp;task=topic&amp;id=956&amp;Itemid=57">Реализация игрового времени</a></div>
</li>
</ul>
<p>
<a class="wikilink1" href="help_classic_qsp.htm" title="help:classic_qsp">Вперёд: классический плеер</a>
</p>
</div>

<!-- wikipage stop -->
</div></body>
</html>