<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU">
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Переменные [Документация QSP]</title>
<link href="default.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="page group">
<!-- wikipage start -->
<!-- TOC START -->

<!-- TOC END -->
<p>
<a class="wikilink1" href="help_principle.htm" title="help:principle">Назад: Порядок работы интерпретатора</a>
</p>
<h1 class="sectionedit1" id="peremennye">Переменные</h1>
<div class="level1">
<p>
Иногда в процессе игры нам требуется на время сохранить какую-либо информацию. Например, герой срывает с дерева яблоки, и нам нужно куда-то "записать", сколько яблок он сорвал. Или же в результате битвы погибает злодей, и нам нужно, чтобы плеер "запомнил", что злодей погиб. Для таких вот "записей", "запоминаний", и существуют переменные.
</p>
<p>
<strong>Переменная</strong> - это именованная "ячейка памяти". То есть это некий кусочек памяти в программе, которому мы назначаем имя.
</p>
<p>
Для удобства можно представлять переменную, как коробку, в которую мы что-нибудь "складываем", например число, или фрагмент текста (или даже несколько значений одновременно - кортеж).
</p>
</div>
<h2 class="sectionedit2" id="tipy_peremennyx">Типы переменных</h2>
<div class="level2">
<p>
Память программ работает совсем не так, как наша, и "запоминать" они могут только определённого типа значения. <strong>QSP</strong> умеет "запоминать" только <strong>целочисленные</strong> (числовые) и <strong>строковые</strong> значения. Особняком можно отметить <strong>кортежи</strong>, которые позволяют упаковать в одну переменную сразу группу значений.
</p>
<p>
Поэтому и переменные в <strong>QSP</strong> делятся на три типа:
</p>
<ul>
<li class="level1"><div class="li"> Целочисленные</div>
</li>
<li class="level1"><div class="li"> Строковые</div>
</li>
<li class="level1"><div class="li"> Кортежи</div>
</li>
</ul>
<p>
<strong>В целочисленных переменных</strong> (иногда для краткости их называют просто числовыми) мы можем хранить только <strong>целые</strong> числа в пределах от -2147483648 до 2147483647.
</p>
<p>
Если мы не поместили никакого значения в целочисленную переменную, то считается, что она хранит значение <strong><code>0</code></strong>. Это <strong>значение по умолчанию</strong> для числовых переменных.
</p>
<p>
<strong>В строковых переменных</strong> (иногда их называют текстовыми переменными) мы можем хранить целые строки текста, и длина таких строк может доходить до двух Гигабайт. Строка не может превысить объём оперативной памяти.
</p>
<p>
Если мы не поместили никакого значения в строковую переменную, то считается, что она хранит пустую строку, т.е. строку совсем без символов. Это <strong>значение по умолчанию</strong> для строковых переменных.
</p>
<p>
<strong>В кортежах</strong> мы можем хранить сразу группу значений, причём это могут быть значения любого из трёх типов: числовые, строковые и другие кортежи. <strong>Не рекомендуется</strong> создавать очень большие кортежи, хотя теоретически кортежи могут быть <em>очень</em> большими. Если вам и правда понадобится <em>настолько</em> большой кортеж, примите во внимание, что как и со строкой, объём занимаемых кортежем данных не может превысить двух Гигабайт, или объёма оперативной памяти.
</p>
<p>
<strong>В переменной можно хранить значение только одного типа!</strong> Переменные <strong><code>%яблоко</code></strong>, <strong><code>$яблоко</code></strong> и <strong><code>яблоко</code></strong> — это одна и та же переменная, но с разным типом значения, которое в ней хранится.
</p>
</div>
<h2 class="sectionedit3" id="sozdanie_peremennyx_i_izmenenie_ix_znachenij">Создание переменных и изменение их значений</h2>
<div class="level2">
<p>
Чтобы создать переменную, мы должны задать ей значение. Это называется операцией <strong>присваивания</strong>.
</p>
<p>
Операция присваивания в <strong>QSP</strong> записывается так:
</p>
<ul>
<li class="level1"><div class="li"> сначала пишется имя переменной</div>
</li>
<li class="level1"><div class="li"> затем ставится знак <strong>равно</strong> (<strong>=</strong>)</div>
</li>
<li class="level1"><div class="li"> после знака <strong>равно</strong> пишется значение, которое мы хотим "записать" в переменную.</div>
</li>
</ul>
<p>
Примеры:
</p>
<p>
</p><pre class="brush: qsp">
! переменной яблоко присваивается число 23
яблоко=23

! переменной $скороговорка присваивается строка Ехал Грека Через Реку
$скороговорка = 'Ехал Грека Через Реку'

! переменной %unit присваивается кортеж значений
%unit = [187, 94, 'steel', [0, 2]]
</pre>
<p>
Как видите, во всех трёх случаях сначала ставится имя переменной, потом знак равенства, а потом значение. Вместо значения можно написать название другой переменной, название функции, или даже целое выражение. Плеер автоматически вычислит <strong>значение</strong> из выражения, функции или переменной, и присвоит это <strong>значение</strong> переменной, стоящей слева от знака <strong>равно</strong>. Примеры:
</p>
<p>
</p><pre class="brush: qsp">
! присваиваем переменной значение другой переменной
$скороговорка_про_Греку = $скороговорка

! присваиваем переменной значение выражения
яблоко = яблоки_в_кармане + яблоки_в_лукошке + яблоки_у_Лёшки

! присваиваем переменной значение функции
случайное_число = rnd
$текущая_локация = $curloc
</pre>
<p>
Не путайте операцию присваивания, и операцию сравнения. Их запись похожа, но операция сравнения обычно следует за ключевыми словами <strong><code>IF</code></strong>, <strong><code>ELSEIF</code></strong> или <strong><code>WHILE</code></strong> и позволяет сравнивать одно значение с другим.
</p>
</div>
<h3 class="sectionedit4" id="mnozhestvennoe_prisvaivanie">Множественное присваивание</h3>
<div class="level3">
<p>
Вы можете одной командой присвоить значения сразу нескольким переменным (множественное присваивание). Для этого:
</p>
<ul>
<li class="level1"><div class="li"> сначала перечисляете через запятую несколько имён переменных</div>
</li>
<li class="level1"><div class="li"> затем ставите знак <strong>равно</strong> (<strong>=</strong>)</div>
</li>
<li class="level1"><div class="li"> после знака <strong>равно</strong> так же через запятую перечисляете значения, которые хотите назначить переменным.</div>
</li>
</ul>
<p>
Примеры:
</p>
<p>
</p><pre class="brush: qsp">
яблоки_в_кармане, яблоки_в_лукошке, яблоки_у_Лёшки = 58, 11, 19
$строка_1, $строка_2 = 'Ехал Грека Через Реку', 'Видит Грека В Реке Рак'
$name, count = 'Старый меч', 2
</pre>
<p>
Во всех трёх командах слева от знака <strong>равно</strong> через запятую перечисляются переменные, которым мы присваиваем значения, а справа через запятую перечисляются значения, которые мы присваиваем переменным.
</p>
<p>
Вместо прямого указания значений можно присваивать значения других переменных, выражений, функций:
</p>
<p>
</p><pre class="brush: qsp">
! три переменные = три значения
red, green, blue = rand(0,255), rand(0,255), rand(0,255)
! две переменные = два значения
яблоки_в_кармане, яблоки_в_лукошке = яблоки_у_Лёшки, яблоки_на_дереве+15
</pre>
<p>
Присваивать значения одной командой очень удобно, если переменные близки по своему смыслу или назначению. Например, одной строкой можно задавать значения сразу нескольким системным переменным в начале игры:
</p>
<p>
</p><pre class="brush: qsp">
usehtml, debug, nosave = 1, 1, 1
bcolor, lcolor, fcolor = rgb(255,255,255), rgb(0,90,90), rgb(0,0,0)
</pre>
<p>
Благодаря возможности одновременно присваивать значения сразу нескольким переменным, можно менять местами данные в двух переменных, не прибегая к помощи третьей:
</p>
<p>
</p><pre class="brush: qsp">
! присваиваем пременным x и y значения 12 и 99
x, y = 12, 99
! меняем местами значения. Теперь в x находится число 99, а в y — 12
x, y = y, x
</pre>
<p>
<strong>Важно помнить!</strong> Слева от знака равенства должно быть столько же переменных, сколько справа значений. Число переменных, и число присваиваемых значений — должны совпадать. Такие записи неверны:
</p>
<p>
</p><pre class="brush: qsp">
! три переменные, а значения только два
raz, dva, tri = 24, 67
! одна переменная, и два значения
chetyre = 89, 21
</pre>
<p>
Так же в одной команде можно использовать лишь один оператор присваивания:
</p>
<p>
</p><pre class="brush: qsp">
! так неправильно:
raz = 24, dva = 67, tri = 89
! а вот так правильно
raz, dva, tri = 24, 67, 89
! и вот так правильно, потому что здесь три команды записаны в одну строку
raz = 24 &amp; dva = 67 &amp; tri = 89
</pre>
</div>
<h3 class="sectionedit5" id="prisvaivanie_iz_kortezha_raspakovka">Присваивание из кортежа (распаковка)</h3>
<div class="level3">
<p>
Поскольку кортежи содержат в себе сразу несколько значений, запись присваивания значений переменным из кортежа может показаться необычной:
</p>
<p>
</p><pre class="brush: qsp">
! %unit = [187, 94, 'steel', [0, 2]]
рост, вес, $материал, %координаты = %unit
</pre>
<p>
Как видите, здесь у нас слева четыре имени переменной, а справа только одно имя переменной-кортежа. Такое присваивание называется <strong>распаковкой</strong> — значения извлекаются из кортежа и помещаются в указанные переменные.
</p>
<p>
Точно так же распаковывается кортеж, даже не помещённый в переменную:
</p>
<p>
</p><pre class="brush: qsp">
рост, вес, $материал, %координаты = [187, 94, 'steel', [0, 2]]
</pre>
<p>
Такая запись мало чем отличается от множественного присваивания, поэтому внешние квадратные скобки не обязательны:
</p>
<p>
</p><pre class="brush: qsp">
рост, вес, $материал, %координаты = 187, 94, 'steel', [0, 2]
</pre>
<p>
Подробнее о работе с кортежами, читайте в <a class="wikilink1" href="help_tuples.htm" title="help:tuples">соответствующем разделе</a>.
</p>
</div>
<h3 class="sectionedit6" id="operatory_set_i_let">Операторы SET и LET</h3>
<div class="level3">
<p>
Из старых версий плеера перекочевали операторы <strong><code id="statement_SET">SET</code></strong> и <strong><code id="statement_LET">LET</code></strong>. Эти операторы явно указывают, что данная команда производит присваивание. Любой из этих операторов может быть поставлен перед операцией присваивания, это никак не влияет на работу переменных. В примере ниже все три варианта присваивания значения переменным равнозначны:
</p>
<p>
</p><pre class="brush: qsp">
SET golden_axe_damage = 120
LET golden_axe_damage = 120
golden_axe_damage = 120
</pre>
<p>
Точно так же, как и в операции присваивания без операторов <strong><code>SET</code></strong> и <strong><code>LET</code></strong>, можно присваивать значения сразу нескольким переменным одной командой и с использованием операторов:
</p>
<p>
</p><pre class="brush: qsp">
set яблоки_в_кармане, яблоки_в_лукошке, яблоки_у_Лёшки = 58, 11, 19
set $строка_1, $строка_2 = 'Ехал Грека Через Реку', 'Видит Грека В Реке Рак'
let $name, count = 'Старый меч', 2
</pre>
<p>
Для улучшения читаемости кода можно использовать оператор <strong><code>SET</code></strong> только для команд с множественным присваиванием.
</p>
<p>
Оператор <strong><code>LET</code></strong> использовать не рекомендуется.
</p>
</div>
<h3 class="sectionedit7" id="izmenenie_tipa_peremennoj">Изменение типа переменной</h3>
<div class="level3">
<p>
Изменить тип переменной в <strong>QSP</strong> можно, просто присвоив ей значение другого типа. Например:
</p>
<p>
</p><pre class="brush: qsp">
! присваиваем переменной строковое значение
$яблоко = 'Антоновка'
! если мы попытаемся вывести на экран числовое значение этой переменной,
! то увидим значение по умолчанию, то есть ноль:
*pl яблоко &amp; ! выведет 0 на экран
! но мы можем изменить тип переменной, записав в неё число
яблоко = 19
! теперь, если мы попытаемся вывести на экран то же числовое значение
! мы увидим число 19
*pl яблоко &amp; ! выведет 19 на экран
! а если мы попытаемся вывести на экран текстовое значение,
! то ничего не увидим, потому что числовое значение затёрло текстовое
*pl $яблоко
</pre>
</div>
<h2 class="sectionedit8" id="naimenovanie_peremennyx">Наименование переменных</h2>
<div class="level2">
<p>
Чтобы не сбивать плеер с толку, названия переменных должны соответствовать следующим условиям:
</p>
<ul>
<li class="level1"><div class="li"> Название переменной <strong>не</strong> должно <strong>начинаться с цифры</strong>.</div>
</li>
<li class="level1"><div class="li"> Оно не должно совпадать с ключевыми словами (cм. <a class="wikilink1" href="help_keywords.htm" title="help:keywords">список ключевых слов</a>).</div>
</li>
<li class="level1"><div class="li"> В названии не должны использоваться пробелы, символы табуляции и следующие символы: <pre class="brush: text">
     ! : &amp; = &lt; &gt; + - * / , ' " ( ) [ ] { } @ ? ;
</pre></div>
</li>
<li class="level1"><div class="li"> Названия строковых переменных должны начинаться с символа <strong><code>$</code></strong>.</div>
</li>
<li class="level1"><div class="li"> Названия кортежей должны начинаться с символа <strong><code>%</code></strong>.</div>
</li>
<li class="level1"><div class="li"> Регистр в названии переменной не важен: <strong><code>деньги</code></strong> и <strong><code>ДеНьГи</code></strong> - одна и та же переменная.</div>
</li>
</ul>
<p>
А вот несколько рекомендаций по тому, как правильно подбирать названия переменных
</p>
<ul>
<li class="level1"><div class="li"> Вместо пробела в названиях можно использовать символ подчеркивания - "<strong><code>_</code></strong>".</div>
</li>
<li class="level1"><div class="li"> Не рекомендуется делать названия длиннее 10-15 символов, это усложняет читаемость кода.</div>
</li>
<li class="level1"><div class="li"> Не стоит использовать в названии переменной <strong>одновременно</strong> символы разных алфавитов, это может запутать вас, и вы допустите ошибку.</div>
</li>
</ul>
<p>
Используйте краткие и ёмкие названия, указывающие на назначение переменной. При этом <strong>QSP</strong> разрешает пользоваться символами любого алфавита:
</p>
<p>
</p><pre class="brush: qsp">
яблоки_в_кармане = 3
$АмулетНаШее = "Ожерелье Гроз"

money_count = 1037
$money_name = "RUB"

我_拿_钥匙 = 1
%饭碗 = ["Rice Bowl", 'Cat-wife ']
</pre>
</div>
<h2 class="sectionedit9" id="udalenie_peremennyx">Удаление переменных</h2>
<div class="level2">
<p>
Удалить переменную можно с помощью оператора <strong><code>KILLVAR</code></strong>.
</p>
<p>
</p><pre class="brush: qsp">
KILLVAR 'имя_переменной'
</pre>
<p>
Имя переменной при этом должно помещаться в кавычки:
</p>
<p>
</p><pre class="brush: qsp">
killvar 'яблоки_в_кармане'
killvar "$АмулетНаШее"
</pre>
<p>
Более подробное описание оператора <strong><code>KILLVAR</code></strong> находится в статье про <a class="wikilink1" href="help_arrays.htm" title="help:arrays">массивы</a>.
</p>
</div>
<h2 class="sectionedit10" id="proverka_suschestvovanija_peremennoj">Проверка существования переменной</h2>
<div class="level2">
<p>
В <strong>QSP</strong> нет специальной команды для проверки существования переменных, однако в силу особенностей движка можно использовать функцию получения размера <a class="wikilink1" href="help_arrays.htm" title="help:arrays">массива</a> <strong><code>ARRSIZE</code></strong>. Если функция вернёт единицу <strong>1</strong>, значит переменная существует; если вернёт <strong>0</strong>, значит переменная не существует.
</p>
<p>
</p><pre class="brush: qsp">
яблоко = 19 &amp; ! создана переменная яблоко
! увидим на экране Переменная "яблоко" существует
if arrsize('яблоко') = 1:
    *pl 'Переменная "яблоко" существует'
else
    *pl 'Переменная "яблоко" не существует'
end

! переменную груша мы не создавали
! увидим на экране Переменная "груша" не существует
if arrsize('груша')=1:
    *pl 'Переменная "груша" существует'
else
    *pl 'Переменная "груша" не существует'
end
</pre>
<p>
Название переменной для функции <strong><code>ARRSIZE</code></strong> указывается внутри кавычек и помещается в круглые скобки. Указывать символ <code>$</code> или <code>%</code> перед названием переменной не обязательно. Вне зависимости от типа значения, которое в этой переменной хранится, <strong><code>ARRSIZE</code></strong> вернёт единицу, если переменная существует:
</p>
<p>
</p><pre class="brush: qsp">
яблоко = 19 &amp; ! в переменную записано число
! обе команды ниже вернут единицу, потому что
! яблоко, $яблоко и %яблоко - это одна и та же переменная
*pl arrsize('яблоко')
*pl arrsize('$яблоко')
*pl arrsize('%яблоко')
</pre>
<p>
О функции <strong><code>ARRSIZE</code></strong> так же можно подробнее почитать в разделе <a class="wikilink1" href="help_arrays.htm" title="help:arrays">"Массивы"</a>.
</p>
</div>
<h2 class="sectionedit11" id="poluchenie_znachenij_iz_peremennyx">Получение значений из переменных</h2>
<div class="level2">
<p>
Чтобы получить значение переменной, достаточно написать её имя в выражении.
</p>
<p>
При этом, чтобы получить кортеж, нужно поставить перед именем переменной <code>%</code>, а чтобы получить строковое значение, нужно поставить перед именем переменной <code>$</code>.
</p>
<p>
Примеры:
</p>
<p>
</p><pre class="brush: qsp">
! присваиваем значение одной переменной - другой
num = int &amp; ! выражение здесь состоит из одной переменной
! выводим значение переменной на экран
*pl $text &amp;! выражение состоит из одной переменной
! вычисляем куб числа, записанного в переменную и выводим на экран
d * d * d &amp;! выражение состоит из двух операций умножения
</pre>
<p>
<strong>Важно!</strong> Если мы пытаемся получить значение переменной, которая не была создана, то такая переменная вернёт значение по умолчанию:
</p>
<ul>
<li class="level1"><div class="li"> для числовых переменных значение по умолчанию <code>0</code> (ноль);</div>
</li>
<li class="level1"><div class="li"> для текстовых переменных значение по умолчанию <code>""</code> (пустая строка);</div>
</li>
<li class="level1"><div class="li"> для кортежей значение по умолчанию <code>[]</code> (пустой кортеж).</div>
</li>
</ul>
</div>
<h2 class="sectionedit12" id="lokalnye_peremennye">Локальные переменные</h2>
<div class="level2">
<p>
В <strong>QSP</strong> есть возможность сделать переменные локальными, то есть их значения будут сохраняться в пределах определённого <em>блока кода</em>, например, только на определённой локации или в отдельном действии.
</p>
<p>
Чтобы объявить переменную локальной, нужно использовать ключевое слово <strong><code id="statement_LOCAL">LOCAL</code></strong>. В общем виде объявление локальной переменной выглядит так:
</p>
<p>
</p><pre class="brush: qsp">
LOCAL имя_переменной = [значение]
</pre>
<p>
Здесь <strong><code>имя_переменной</code></strong> — это имя переменной, которую мы объявляем, а <strong><code>[значение]</code></strong> — это любое значение, которое мы этой переменной присваиваем. Пример:
</p>
<p>
</p><pre class="brush: qsp">
! объявляем локальную переменную **tempora** со значением **12**
local tempora = 12
</pre>
<p>
Эта запись очень похожа на объявление переменной через оператор <strong><code>SET</code></strong>, и точно так же, как для оператора <strong><code>SET</code></strong>, для оператора <strong><code>LOCAL</code></strong> существует возможность объявить сразу несколько локальных переменных:
</p>
<p>
</p><pre class="brush: qsp">
! множественное объявление локальных переменных
local x, y, $item = 11, 19, "Старый меч"
</pre>
<p>
Как видите, сразу после оператора <strong><code>LOCAL</code></strong> через запятую перечислены имена объявляемых переменных, затем стоит знак равенства и после него перчислены значения, которые мы присваиваем этим переменным. Число переменных слева от знака <strong><code>=</code></strong> и число значений справа должны совпадать.
</p>
<p>
Однако, в отличие от оператора <strong><code>SET</code></strong> оператор <strong><code>LOCAL</code></strong> позволяет нам назначить локальные переменные без присвоения им значений. Для этого достаточно просто перечислить после оператора <strong><code>LOCAL</code></strong> через запятую названия переменных:
</p>
<p>
</p><pre class="brush: qsp">
local $название_предмета, количество, цена
</pre>
<p>
Здесь оператор <strong><code>LOCAL</code></strong> работает без операции присваивания. Локальные переменные создаются, но <strong><code>arrsize</code></strong> для них покажет <strong><code>0</code></strong>.
</p>
<p>
Собственные локальные переменные можно создавать для таких блоков кода как:
</p>
<ul>
<li class="level1"><div class="li"> Локации сами со себе.</div>
</li>
<li class="level1"><div class="li"> Код, передаваемый оператору <strong><code>DYNAMIC</code></strong> или функции <strong><code>DYNEVAL</code></strong> в виде текста.</div>
</li>
<li class="level1"><div class="li"> Код, выполняемый при нажатии на гиперссылку.</div>
</li>
<li class="level1"><div class="li"> Код каждого отдельного Действия (<strong><a class="wikilink1" href="help_acts.htm" title="help:acts">ACT</a></strong>).</div>
</li>
<li class="level1"><div class="li"> Код каждого отдельного Цикла (<strong><a class="wikilink1" href="help_cycle.htm" title="help:cycle">LOOP</a></strong>)</div>
</li>
</ul>
<p>
<strong>Внимание!</strong> У локальных переменных есть одна особенность, которую нужно очень чётко понимать. Значение объявленной в данном блоке кода локальной переменной транслируется и во все вложенные, или вызванные из данного, блоки кода. Например, если на локации объявлена локальная переменная, то её значение транслируется во все вызываемые с помощью <strong><code>GOSUB</code></strong> или <strong><code>FUNC</code></strong> локации, в блоки кода для <strong><code>DYNAMIC</code></strong>/<strong><code>DYNEVAL</code></strong>, в блоки циклов и так далее. Пример:
</p>
<p>
</p><pre class="brush: qsp">
# start
  ! из этой локации мы будем вызывать локацию foo
  i=99 &amp; ! объявляем глобальную переменную
  gosub 'foo'
  *nl i &amp; ! на экране увидим число 99
- start -

# foo
  ! на этой локации объявляем локальную переменную
  local i=0
  ! локальная переменная транслируется в цикл
  loop while i&lt;10 step i+=1:
    ! в цикле мы вызываем локацию undo
    gosub 'undo'
    ! и так же в цикле мы работаем с переменной,
    ! объявленной на локации foo
  end
  *nl i &amp; ! на экране увидим число 10
- foo -

# undo
  ! в эту локацию из цикла с локации foo
  ! транслируется всё та же локальная переменная
  ! объявленная на локации foo
  i+=1 &amp; ! увеличиваем значение переменной, влияя на значение в foo
  *p 'undo:&lt;&lt;i&gt;&gt;, ' &amp; ! на экране появятся числа 1,3,5,7,9 с припиской undo:
- undo -
</pre>
<p>
<strong>Однако!</strong> Значения локальных переменных не транслируются в действия (в отличие от значений массива <strong><code>ARGS</code></strong> на текущей локации):
</p>
<p>
</p><pre class="brush: qsp">
$args[0] = 'текущая локация'
local $var = 'локальная переменная'
*pl $args[0]
*pl $var
act "Вывести значения":
  *pl $args[0]
  *pl $var
end
</pre>
<p>
<strong>Важно.</strong> Значения локальных переменных не передаются в локации-обработчики событий, однако передаются на локации-обработчики пунктов меню. Будьте внимательны.
</p>
</div>
<h3 class="sectionedit13" id="primery_naznachenija_lokalnyx_peremennyx">Примеры назначения локальных переменных</h3>
<div class="level3">
<p>
Две локации, на каждой из которых собственная переменная <strong><code>i</code></strong>:
</p>
<p>
</p><pre class="brush: qsp">
# локация 1
  if i=0: i=99 &amp; ! значение переменной i задаётся лишь раз
  *pl "Глобальное i = &lt;&lt;i&gt;&gt;"
  act "На локацию 2": goto 'локация 2'
- локация 1 -

# локация 2
  *pl "Глобальное i = &lt;&lt;i&gt;&gt;"
  local i=137 &amp; ! значение переменной i задаётся лишь раз
  *pl "Локальное i = &lt;&lt;i&gt;&gt;"
  act "На локацию 1": goto 'локация 1'
- локация 2 -
</pre>
<p>
Ещё пример с двумя локациями:
</p>
<p>
</p><pre class="brush: qsp">
! этот код последовательно выведет на экран числа 12, 549 и 99, 549
# start
  x=99
  z=4608
  gosub 'foo'
  *pl x &amp; *pl z  &amp; ! на экран выведутся числа 99 и 549
- start -

# foo
  local x &amp; ! объявляем переменную x локальной для данной локации
  x=12  &amp; ! изменяем значение переменной x
  z=549
  *pl x &amp; *pl z  &amp; ! на экран выведутся числа 12 и 549
- foo -
</pre>
<p>
Пример объявления локальных переменных в коде для <strong><code>DYNEVAL</code></strong> и в цикле:
</p>
<p>
</p><pre class="brush: qsp">
$chkObjWord = {
  ! это код, записанный в виде текста в переменную $chkObjWord
  ! в локальную переменную $word записываем слово,
  ! по которому производим поиск
  local $word = $args[0]
  loop local i = 1 while no i &gt; countobj step i += 1:
    ! используем локальную переменную i внутри цикла
    ! цикл выполняется пока счётчик не превысит число предметов
    if instr($getobj(i), $word) &lt;&gt; 0:
      ! как только в названии очередного предмета
      ! встречается рассматриваемое слово
      result = i  &amp; ! возвращаем позицию
      exit  &amp; ! закрываем функцию
    end
  end
}
object_position = dyneval($chkObjWord, 'граната')
</pre>
<p>
Локальные переменные можно объявлять и внутри действий:
</p>
<p>
</p><pre class="brush: qsp">
i=99
act "Действие с локальной i":
  local i = 449933
  *pl i
end
act "Действие с глобальной i":
  *pl i
end
</pre>
<p>
<a class="wikilink1" href="help_expressions.htm" title="help:expressions">Вперёд: Выражения</a>
</p>
</div>

<!-- wikipage stop -->
</div></body>
</html>